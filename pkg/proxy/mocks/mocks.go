// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/Semior001/groxy/pkg/discovery"
	"google.golang.org/grpc/metadata"
	"sync"
)

// MatcherMock is a mock implementation of proxy.Matcher.
//
// 	func TestSomethingThatUsesMatcher(t *testing.T) {
//
// 		// make and configure a mocked proxy.Matcher
// 		mockedMatcher := &MatcherMock{
// 			MatchMetadataFunc: func(s string, mD metadata.MD) discovery.Matches {
// 				panic("mock out the MatchMetadata method")
// 			},
// 			UpstreamsFunc: func() []discovery.Upstream {
// 				panic("mock out the Upstreams method")
// 			},
// 		}
//
// 		// use mockedMatcher in code that requires proxy.Matcher
// 		// and then make assertions.
//
// 	}
type MatcherMock struct {
	// MatchMetadataFunc mocks the MatchMetadata method.
	MatchMetadataFunc func(s string, mD metadata.MD) discovery.Matches

	// UpstreamsFunc mocks the Upstreams method.
	UpstreamsFunc func() []discovery.Upstream

	// calls tracks calls to the methods.
	calls struct {
		// MatchMetadata holds details about calls to the MatchMetadata method.
		MatchMetadata []struct {
			// S is the s argument value.
			S string
			// MD is the mD argument value.
			MD metadata.MD
		}
		// Upstreams holds details about calls to the Upstreams method.
		Upstreams []struct {
		}
	}
	lockMatchMetadata sync.RWMutex
	lockUpstreams     sync.RWMutex
}

// MatchMetadata calls MatchMetadataFunc.
func (mock *MatcherMock) MatchMetadata(s string, mD metadata.MD) discovery.Matches {
	if mock.MatchMetadataFunc == nil {
		panic("MatcherMock.MatchMetadataFunc: method is nil but Matcher.MatchMetadata was just called")
	}
	callInfo := struct {
		S  string
		MD metadata.MD
	}{
		S:  s,
		MD: mD,
	}
	mock.lockMatchMetadata.Lock()
	mock.calls.MatchMetadata = append(mock.calls.MatchMetadata, callInfo)
	mock.lockMatchMetadata.Unlock()
	return mock.MatchMetadataFunc(s, mD)
}

// MatchMetadataCalls gets all the calls that were made to MatchMetadata.
// Check the length with:
//     len(mockedMatcher.MatchMetadataCalls())
func (mock *MatcherMock) MatchMetadataCalls() []struct {
	S  string
	MD metadata.MD
} {
	var calls []struct {
		S  string
		MD metadata.MD
	}
	mock.lockMatchMetadata.RLock()
	calls = mock.calls.MatchMetadata
	mock.lockMatchMetadata.RUnlock()
	return calls
}

// Upstreams calls UpstreamsFunc.
func (mock *MatcherMock) Upstreams() []discovery.Upstream {
	if mock.UpstreamsFunc == nil {
		panic("MatcherMock.UpstreamsFunc: method is nil but Matcher.Upstreams was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUpstreams.Lock()
	mock.calls.Upstreams = append(mock.calls.Upstreams, callInfo)
	mock.lockUpstreams.Unlock()
	return mock.UpstreamsFunc()
}

// UpstreamsCalls gets all the calls that were made to Upstreams.
// Check the length with:
//     len(mockedMatcher.UpstreamsCalls())
func (mock *MatcherMock) UpstreamsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUpstreams.RLock()
	calls = mock.calls.Upstreams
	mock.lockUpstreams.RUnlock()
	return calls
}

// ServerStreamMock is a mock implementation of proxy.ServerStream.
//
// 	func TestSomethingThatUsesServerStream(t *testing.T) {
//
// 		// make and configure a mocked proxy.ServerStream
// 		mockedServerStream := &ServerStreamMock{
// 			ContextFunc: func() context.Context {
// 				panic("mock out the Context method")
// 			},
// 			RecvMsgFunc: func(m any) error {
// 				panic("mock out the RecvMsg method")
// 			},
// 			SendHeaderFunc: func(mD metadata.MD) error {
// 				panic("mock out the SendHeader method")
// 			},
// 			SendMsgFunc: func(m any) error {
// 				panic("mock out the SendMsg method")
// 			},
// 			SetHeaderFunc: func(mD metadata.MD) error {
// 				panic("mock out the SetHeader method")
// 			},
// 			SetTrailerFunc: func(mD metadata.MD)  {
// 				panic("mock out the SetTrailer method")
// 			},
// 		}
//
// 		// use mockedServerStream in code that requires proxy.ServerStream
// 		// and then make assertions.
//
// 	}
type ServerStreamMock struct {
	// ContextFunc mocks the Context method.
	ContextFunc func() context.Context

	// RecvMsgFunc mocks the RecvMsg method.
	RecvMsgFunc func(m any) error

	// SendHeaderFunc mocks the SendHeader method.
	SendHeaderFunc func(mD metadata.MD) error

	// SendMsgFunc mocks the SendMsg method.
	SendMsgFunc func(m any) error

	// SetHeaderFunc mocks the SetHeader method.
	SetHeaderFunc func(mD metadata.MD) error

	// SetTrailerFunc mocks the SetTrailer method.
	SetTrailerFunc func(mD metadata.MD)

	// calls tracks calls to the methods.
	calls struct {
		// Context holds details about calls to the Context method.
		Context []struct {
		}
		// RecvMsg holds details about calls to the RecvMsg method.
		RecvMsg []struct {
			// M is the m argument value.
			M any
		}
		// SendHeader holds details about calls to the SendHeader method.
		SendHeader []struct {
			// MD is the mD argument value.
			MD metadata.MD
		}
		// SendMsg holds details about calls to the SendMsg method.
		SendMsg []struct {
			// M is the m argument value.
			M any
		}
		// SetHeader holds details about calls to the SetHeader method.
		SetHeader []struct {
			// MD is the mD argument value.
			MD metadata.MD
		}
		// SetTrailer holds details about calls to the SetTrailer method.
		SetTrailer []struct {
			// MD is the mD argument value.
			MD metadata.MD
		}
	}
	lockContext    sync.RWMutex
	lockRecvMsg    sync.RWMutex
	lockSendHeader sync.RWMutex
	lockSendMsg    sync.RWMutex
	lockSetHeader  sync.RWMutex
	lockSetTrailer sync.RWMutex
}

// Context calls ContextFunc.
func (mock *ServerStreamMock) Context() context.Context {
	if mock.ContextFunc == nil {
		panic("ServerStreamMock.ContextFunc: method is nil but ServerStream.Context was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContext.Lock()
	mock.calls.Context = append(mock.calls.Context, callInfo)
	mock.lockContext.Unlock()
	return mock.ContextFunc()
}

// ContextCalls gets all the calls that were made to Context.
// Check the length with:
//     len(mockedServerStream.ContextCalls())
func (mock *ServerStreamMock) ContextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContext.RLock()
	calls = mock.calls.Context
	mock.lockContext.RUnlock()
	return calls
}

// RecvMsg calls RecvMsgFunc.
func (mock *ServerStreamMock) RecvMsg(m any) error {
	if mock.RecvMsgFunc == nil {
		panic("ServerStreamMock.RecvMsgFunc: method is nil but ServerStream.RecvMsg was just called")
	}
	callInfo := struct {
		M any
	}{
		M: m,
	}
	mock.lockRecvMsg.Lock()
	mock.calls.RecvMsg = append(mock.calls.RecvMsg, callInfo)
	mock.lockRecvMsg.Unlock()
	return mock.RecvMsgFunc(m)
}

// RecvMsgCalls gets all the calls that were made to RecvMsg.
// Check the length with:
//     len(mockedServerStream.RecvMsgCalls())
func (mock *ServerStreamMock) RecvMsgCalls() []struct {
	M any
} {
	var calls []struct {
		M any
	}
	mock.lockRecvMsg.RLock()
	calls = mock.calls.RecvMsg
	mock.lockRecvMsg.RUnlock()
	return calls
}

// SendHeader calls SendHeaderFunc.
func (mock *ServerStreamMock) SendHeader(mD metadata.MD) error {
	if mock.SendHeaderFunc == nil {
		panic("ServerStreamMock.SendHeaderFunc: method is nil but ServerStream.SendHeader was just called")
	}
	callInfo := struct {
		MD metadata.MD
	}{
		MD: mD,
	}
	mock.lockSendHeader.Lock()
	mock.calls.SendHeader = append(mock.calls.SendHeader, callInfo)
	mock.lockSendHeader.Unlock()
	return mock.SendHeaderFunc(mD)
}

// SendHeaderCalls gets all the calls that were made to SendHeader.
// Check the length with:
//     len(mockedServerStream.SendHeaderCalls())
func (mock *ServerStreamMock) SendHeaderCalls() []struct {
	MD metadata.MD
} {
	var calls []struct {
		MD metadata.MD
	}
	mock.lockSendHeader.RLock()
	calls = mock.calls.SendHeader
	mock.lockSendHeader.RUnlock()
	return calls
}

// SendMsg calls SendMsgFunc.
func (mock *ServerStreamMock) SendMsg(m any) error {
	if mock.SendMsgFunc == nil {
		panic("ServerStreamMock.SendMsgFunc: method is nil but ServerStream.SendMsg was just called")
	}
	callInfo := struct {
		M any
	}{
		M: m,
	}
	mock.lockSendMsg.Lock()
	mock.calls.SendMsg = append(mock.calls.SendMsg, callInfo)
	mock.lockSendMsg.Unlock()
	return mock.SendMsgFunc(m)
}

// SendMsgCalls gets all the calls that were made to SendMsg.
// Check the length with:
//     len(mockedServerStream.SendMsgCalls())
func (mock *ServerStreamMock) SendMsgCalls() []struct {
	M any
} {
	var calls []struct {
		M any
	}
	mock.lockSendMsg.RLock()
	calls = mock.calls.SendMsg
	mock.lockSendMsg.RUnlock()
	return calls
}

// SetHeader calls SetHeaderFunc.
func (mock *ServerStreamMock) SetHeader(mD metadata.MD) error {
	if mock.SetHeaderFunc == nil {
		panic("ServerStreamMock.SetHeaderFunc: method is nil but ServerStream.SetHeader was just called")
	}
	callInfo := struct {
		MD metadata.MD
	}{
		MD: mD,
	}
	mock.lockSetHeader.Lock()
	mock.calls.SetHeader = append(mock.calls.SetHeader, callInfo)
	mock.lockSetHeader.Unlock()
	return mock.SetHeaderFunc(mD)
}

// SetHeaderCalls gets all the calls that were made to SetHeader.
// Check the length with:
//     len(mockedServerStream.SetHeaderCalls())
func (mock *ServerStreamMock) SetHeaderCalls() []struct {
	MD metadata.MD
} {
	var calls []struct {
		MD metadata.MD
	}
	mock.lockSetHeader.RLock()
	calls = mock.calls.SetHeader
	mock.lockSetHeader.RUnlock()
	return calls
}

// SetTrailer calls SetTrailerFunc.
func (mock *ServerStreamMock) SetTrailer(mD metadata.MD) {
	if mock.SetTrailerFunc == nil {
		panic("ServerStreamMock.SetTrailerFunc: method is nil but ServerStream.SetTrailer was just called")
	}
	callInfo := struct {
		MD metadata.MD
	}{
		MD: mD,
	}
	mock.lockSetTrailer.Lock()
	mock.calls.SetTrailer = append(mock.calls.SetTrailer, callInfo)
	mock.lockSetTrailer.Unlock()
	mock.SetTrailerFunc(mD)
}

// SetTrailerCalls gets all the calls that were made to SetTrailer.
// Check the length with:
//     len(mockedServerStream.SetTrailerCalls())
func (mock *ServerStreamMock) SetTrailerCalls() []struct {
	MD metadata.MD
} {
	var calls []struct {
		MD metadata.MD
	}
	mock.lockSetTrailer.RLock()
	calls = mock.calls.SetTrailer
	mock.lockSetTrailer.RUnlock()
	return calls
}
